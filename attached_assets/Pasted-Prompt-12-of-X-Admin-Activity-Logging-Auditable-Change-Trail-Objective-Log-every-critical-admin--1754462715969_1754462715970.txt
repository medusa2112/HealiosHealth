Prompt 12 of X: Admin Activity Logging — Auditable Change Trail
Objective: Log every critical admin action (product edits, refunds, uploads, deletions) with full attribution (who, what, when, where). This ensures compliance, traceability, and internal accountability.

✅ PHASE 1: SYSTEM SCAN (TRACEABILITY VULNERABILITIES)
Before building, audit the system for:

❌ Unattributed mutations

Product CRUD, refunds, uploads, etc. occur without logging who triggered them

Refunds can be triggered without storing the admin’s identity

❌ Missing admin ID in request context

Confirm req.user.id is always injected into authenticated admin requests

✅ users table must include:

id, email, role (confirmed from earlier prompts)

🧱 PHASE 2: ADD admin_logs TABLE TO SCHEMA
In /db/schema.ts:

ts
Copy
Edit
export const admin_logs = pgTable("admin_logs", {
  id: uuid("id").defaultRandom().primaryKey(),
  admin_id: uuid("admin_id").notNull(),
  action_type: varchar("action_type", { length: 64 }).notNull(), // e.g. "refund", "edit_product"
  target_type: varchar("target_type", { length: 64 }).notNull(), // e.g. "order", "product"
  target_id: uuid("target_id").notNull(),
  details: json("details"), // optional metadata
  timestamp: timestamp("timestamp").defaultNow(),
});
Then run:

bash
Copy
Edit
npx drizzle-kit push
🛠️ PHASE 3: INJECT LOGIC INTO ADMIN ACTIONS
1. Refund Logging (/routes/admin/orders.ts)
Update refund logic:

ts
Copy
Edit
await db.update(orders).set({ refund_status: "refunded" }).where(eq(orders.id, orderId));

await db.insert(admin_logs).values({
  admin_id: req.user.id,
  action_type: "refund",
  target_type: "order",
  target_id: orderId,
  details: { refund_id: refund.id, amount: refund.amount / 100 },
});
2. Product Edit/Delete/Add (/routes/admin/products.ts)
Log product changes:

ts
Copy
Edit
await db.insert(admin_logs).values({
  admin_id: req.user.id,
  action_type: "edit_product", // or "delete_product", "add_product"
  target_type: "product",
  target_id: product.id,
  details: updatedFields,
});
Capture what changed in details, e.g. { price: 24.99, name: "Updated Product" }

3. Image Upload Logging (/routes/admin/uploads.ts)
After image upload completes:

ts
Copy
Edit
await db.insert(admin_logs).values({
  admin_id: req.user.id,
  action_type: "upload_image",
  target_type: "product",
  target_id: "N/A",
  details: { image_url: (req.file as any).path },
});
💻 PHASE 4: ADMIN LOG VIEW UI /admin/logs.tsx
tsx
Copy
Edit
import { useEffect, useState } from "react";

export default function AdminLogs() {
  const [logs, setLogs] = useState([]);

  useEffect(() => {
    fetch("/admin/logs").then(res => res.json()).then(setLogs);
  }, []);

  return (
    <div className="p-6 space-y-4">
      <h1 className="text-xl font-bold">Admin Activity Logs</h1>

      {logs.map((log: any) => (
        <div key={log.id} className="border p-4 rounded">
          <div>🧑 Admin ID: {log.admin_id}</div>
          <div>⚡ Action: {log.action_type}</div>
          <div>📦 Target: {log.target_type} → {log.target_id}</div>
          <div>📅 Time: {new Date(log.timestamp).toLocaleString()}</div>
          {log.details && <pre className="text-xs bg-gray-100 p-2 rounded">{JSON.stringify(log.details, null, 2)}</pre>}
        </div>
      ))}
    </div>
  );
}
🔁 PHASE 5: LOG INTEGRITY TESTING
Action	Log Expected
Admin adds product	add_product with product ID
Admin edits product price	edit_product with diff
Admin uploads image	upload_image with Cloudinary URL
Admin refunds order	refund with refund metadata
Access /admin/logs	List of latest 50–100 events

🛡️ BONUS PROTECTION (RECOMMENDED)
Feature	Reason
Immutable logs	Prevent accidental deletion
Pagination / filters	Keep audit UI fast
Admin name/email lookup	Easier to identify humans
Soft delete products	Log deletion without losing data integrity

📦 OUTPUT FROM THIS PROMPT
admin_logs table in DB

Auto-logging of all key admin actions:

Refunds

Product changes

Uploads

Admin-only UI view of logs

Full attribution of who did what, when, and to what target