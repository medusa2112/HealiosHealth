Good. Phase 0 surfaced the root cause: **single-stack auth** bleeding across Customer and Admin. We fix this by **hard-separating identities, cookies, sessions, routes, and storage**, then repairing admin write paths with transactions and versioning.

Below is **Phase 1 (Plan) + Phase 2 (Safety/Parity) + ready-to-paste prompts and code diffs**. Minimal blast radius, reversible, PR-sized.

# Answer

## Phase 1 — Target Architecture (explicit, diffable)

### Separation Contract

* **Tables**

  * `users` (customers only)
  * `admins` (new, admins only)
  * `orders`, `carts`, etc. link to `users.id` only
* **Sessions**

  * Customer session: cookie `hh_cust_sess`, store/table `session_customers`
  * Admin session: cookie `hh_admin_sess`, store/table `session_admins`
* **Routes**

  * Customer auth: `/api/auth/customer/login|register|logout`
  * Admin auth: `/api/auth/admin/login|logout`
  * Admin app served only under `/admin/*`
* **Middleware firewalls**

  * `requireCustomer`: validates `hh_cust_sess` only
  * `requireAdmin`: validates `hh_admin_sess` only + role check + optional IP allowlist
* **Security**

  * CSRF per-surface (separate instances; cookie names: `csrf_cust`, `csrf_admin`)
  * CORS: explicit origins only; no `*` with credentials
  * Rate limit:

    * Customer: 10/min/login, lock 10 min after 5 fails
    * Admin: 5/min/login, lock 30 min after 3 fails
  * Admin optional: TOTP 2FA toggle via `ADMIN_2FA_ENABLED`
* **Cookie policies**

  * Customer: `httpOnly`, `secure` (prod), `sameSite=Lax`, `path=/`
  * Admin: `httpOnly`, `secure` (prod), `sameSite=Strict`, `path=/admin`
  * Dynamic `secure` by `x-forwarded-proto === 'https'`
* **CS/Content writes**

  * All admin writes within `drizzle.transaction(...)`
  * Add optimistic locking column `version int` on content/products
* **Env contract** (`.env.example`)

  * Required: `SESSION_SECRET_CUSTOMER`, `SESSION_SECRET_ADMIN`, `DATABASE_URL`, `NODE_ENV`, `PROD_ORIGINS`, `DEV_ORIGINS`, `ADMIN_IP_ALLOWLIST` (csv, optional), `ADMIN_2FA_ENABLED` (true/false)

### Files to add/modify

* `src/server/auth/sessionCustomer.ts`
* `src/server/auth/sessionAdmin.ts`
* `src/server/mw/requireCustomer.ts`
* `src/server/mw/requireAdmin.ts`
* `src/server/routes/authCustomer.ts`
* `src/server/routes/authAdmin.ts`
* `src/server/routes/adminProducts.ts` (wrap in tx + optimistic locking)
* `src/shared/schema.ts` (add `admins`, `product.version`)
* `drizzle/xxxx_add_admins_and_versions.ts` (migrations)
* `src/server/security/cors.ts`, `csrfCustomer.ts`, `csrfAdmin.ts`
* `src/server/health.ts` (`/health/auth`, `/status`)
* `src/server/config/env.ts` (strict loader + parity checks)
* `src/server/tests/**` (auth + e2e)

### Rollback

* All changes are in branch `fix/auth-separation`
* Reversible migrations (down removes `admins` table and `version` column)
* Feature-flag routing: old `/api/auth/login` remains available behind `ENABLE_LEGACY_LOGIN=false` (default false)

---

## Phase 2 — Safety & Parity (PR 1)

**Goal:** Put guardrails in place **before** touching flows.

### 1) Create branch and snapshot

```bash
git checkout -b fix/auth-separation
git add -A && git commit -m "snapshot: pre-auth-separation baseline"
```

### 2) Add strict env loader

`src/server/config/env.ts`

```ts
import * as z from 'zod';

const schema = z.object({
  NODE_ENV: z.enum(['development','test','production']).default('development'),
  DATABASE_URL: z.string().url(),
  SESSION_SECRET_CUSTOMER: z.string().min(32),
  SESSION_SECRET_ADMIN: z.string().min(32),
  PROD_ORIGINS: z.string().optional(), // csv
  DEV_ORIGINS: z.string().optional(),  // csv
  ADMIN_IP_ALLOWLIST: z.string().optional(), // csv
  ADMIN_2FA_ENABLED: z.enum(['true','false']).default('false'),
  PORT: z.string().default('5000')
});

const parsed = schema.safeParse(process.env);
if (!parsed.success) {
  console.error('Env validation failed', parsed.error.flatten());
  process.exit(1);
}
export const ENV = {
  ...parsed.data,
  prodOrigins: (parsed.data.PROD_ORIGINS ?? '').split(',').filter(Boolean),
  devOrigins: (parsed.data.DEV_ORIGINS ?? '').split(',').filter(Boolean),
  isProd: parsed.data.NODE_ENV === 'production'
};
```

### 3) `.env.example`

```
NODE_ENV=development
DATABASE_URL=postgres://...
SESSION_SECRET_CUSTOMER=change-me-32chars-min
SESSION_SECRET_ADMIN=change-me-32chars-min
PROD_ORIGINS=https://thehealios.com,https://www.thehealios.com
DEV_ORIGINS=http://localhost:5000,http://127.0.0.1:5000
ADMIN_IP_ALLOWLIST=
ADMIN_2FA_ENABLED=false
PORT=5000
```

### 4) Health endpoints

`src/server/health.ts`

```ts
import { Router } from 'express';
import type { Pool } from 'pg';

export const healthRouter = (db: Pool) => {
  const r = Router();
  r.get('/health/auth', (req, res) => {
    const cust = req.cookies?.hh_cust_sess ? 'present' : 'absent';
    const adm  = req.cookies?.hh_admin_sess ? 'present' : 'absent';
    res.json({ custCookie: cust, adminCookie: adm, nodeEnv: process.env.NODE_ENV });
  });
  r.get('/status', async (_req, res) => {
    // add a trivial DB query if desired
    res.json({ ok: true, migrationLevel: process.env.DRIZZLE_MIGRATION ?? 'unknown' });
  });
  return r;
};
```

### 5) CORS (no wildcard + credentials)

`src/server/security/cors.ts`

```ts
import cors from 'cors';
import { ENV } from '../config/env';

const origins = ENV.isProd ? ENV.prodOrigins : ENV.devOrigins;
export const corsMw = cors({
  origin: (origin, cb) => {
    if (!origin) return cb(null, true); // allow same-origin
    if (origins.includes(origin)) return cb(null, true);
    cb(new Error(`CORS blocked: ${origin}`));
  },
  credentials: true
});
```

### 6) Wire safety middleware (no functional changes yet)

In your server bootstrap:

```ts
app.use(require('cookie-parser')());
app.use(corsMw);
// mount health
app.use(healthRouter(db));
```

**PR 1 Output:** env validation, `.env.example`, CORS hardening, health endpoints.
**Stop and run:** confirm no regressions.

---

## Phase 3 — Schema & Migrations (PR 2)

### Drizzle schema additions

`src/shared/schema.ts` (additions only)

```ts
import { pgTable, serial, text, integer, timestamp, boolean } from 'drizzle-orm/pg-core';

export const admins = pgTable('admins', {
  id: serial('id').primaryKey(),
  email: text('email').notNull().unique(),
  passwordHash: text('password_hash').notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  lastLoginAt: timestamp('last_login_at'),
  totpSecret: text('totp_secret'), // optional 2FA
  active: boolean('active').default(true).notNull(),
});

export const products = /* existing */ null!; // illustrative
// add optimistic locking to product/content tables:
export const productsWithVersion = {
  version: integer('version').default(0).notNull()
};
```

### Migration (example)

`drizzle/20250811_admins_and_versions.sql`

```sql
BEGIN;

CREATE TABLE IF NOT EXISTS admins (
  id serial PRIMARY KEY,
  email text NOT NULL UNIQUE,
  password_hash text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  last_login_at timestamptz NULL,
  totp_secret text NULL,
  active boolean NOT NULL DEFAULT true
);

-- optimistic locking (adjust table names as applicable)
ALTER TABLE products ADD COLUMN IF NOT EXISTS version int NOT NULL DEFAULT 0;

-- separate session tables if using connect-pg-simple
-- (if you currently use a single "session" table, create two)
CREATE TABLE IF NOT EXISTS session_customers (LIKE session INCLUDING ALL);
CREATE TABLE IF NOT EXISTS session_admins (LIKE session INCLUDING ALL);

COMMIT;
```

**PR 2 Output:** new `admins` table, add `version` column(s), session tables.
**Stop and run:** apply migrations in Replit, verify tables exist.

---

## Phase 4 — Dual Session Middlewares (PR 3)

### Customer session

`src/server/auth/sessionCustomer.ts`

```ts
import session from 'express-session';
import pgSimple from 'connect-pg-simple';
import { ENV } from '../config/env';

const PgSession = pgSimple(session);
export const customerSession = session({
  name: 'hh_cust_sess',
  secret: process.env.SESSION_SECRET_CUSTOMER!,
  resave: false,
  saveUninitialized: false,
  rolling: true,
  cookie: {
    httpOnly: true,
    sameSite: 'lax',
    path: '/',
    secure: false // flipped at runtime by proxy/https
  },
  store: new PgSession({
    tableName: 'session_customers',
    conString: ENV.DATABASE_URL
  })
});
```

### Admin session

`src/server/auth/sessionAdmin.ts`

```ts
import session from 'express-session';
import pgSimple from 'connect-pg-simple';
import { ENV } from '../config/env';

const PgSession = pgSimple(session);
export const adminSession = session({
  name: 'hh_admin_sess',
  secret: process.env.SESSION_SECRET_ADMIN!,
  resave: false,
  saveUninitialized: false,
  rolling: true,
  cookie: {
    httpOnly: true,
    sameSite: 'strict',
    path: '/admin',
    secure: false
  },
  store: new PgSession({
    tableName: 'session_admins',
    conString: ENV.DATABASE_URL
  })
});
```

### Enforce secure cookies behind proxy

In server bootstrap:

```ts
app.set('trust proxy', 1);
app.use((req, _res, next) => {
  const isHttps = req.secure || req.headers['x-forwarded-proto'] === 'https';
  if (isHttps) {
    // express-session reads this flag per request, patch as needed
    req.session.cookie.secure = true;
  }
  next();
});
```

Mount them on distinct surfaces:

```ts
app.use('/api', customerSession);
app.use('/admin', adminSession);
```

**PR 3 Output:** two independent sessions live; no routing changes yet.
**Stop and test:** cookies created with correct names per path.

---

## Phase 5 — Split Auth Routes + Firewalls (PR 4)

### Middleware guards

`src/server/mw/requireCustomer.ts`

```ts
import { RequestHandler } from 'express';
export const requireCustomer: RequestHandler = (req, res, next) => {
  const sid = req.cookies?.hh_cust_sess;
  if (!sid || !req.session?.userId) return res.status(401).json({ error: 'Customer auth required' });
  next();
};
```

`src/server/mw/requireAdmin.ts`

```ts
import { RequestHandler } from 'express';
import { ENV } from '../config/env';

const ips = new Set((ENV.ADMIN_IP_ALLOWLIST ?? '').split(',').map(s => s.trim()).filter(Boolean));

export const requireAdmin: RequestHandler = (req, res, next) => {
  const sid = req.cookies?.hh_admin_sess;
  if (!sid || !req.session?.adminId) return res.status(401).json({ error: 'Admin auth required' });
  if (ips.size && !ips.has(req.ip)) return res.status(403).json({ error: 'IP not allowed' });
  next();
};
```

### Customer auth routes

`src/server/routes/authCustomer.ts`

```ts
import { Router } from 'express';
import bcrypt from 'bcrypt';
import { db } from '../db'; // drizzle
import { users } from '../../shared/schema';

export const authCustomer = Router();

authCustomer.post('/login', async (req, res) => {
  const { email, password } = req.body ?? {};
  const u = await db.query.users.findFirst({ where: (t, { eq }) => eq(t.email, email) });
  if (!u) return res.status(401).json({ error: 'Invalid credentials' });
  const ok = await bcrypt.compare(password, u.passwordHash);
  if (!ok) return res.status(401).json({ error: 'Invalid credentials' });
  req.session.userId = u.id;
  return res.json({ ok: true });
});

authCustomer.post('/register', async (req, res) => {
  const { email, password } = req.body ?? {};
  const hash = await bcrypt.hash(password, 12);
  const [u] = await db.insert(users).values({ email, passwordHash: hash, role: 'customer' }).returning();
  req.session.userId = u.id;
  return res.json({ ok: true });
});

authCustomer.post('/logout', (req, res) => {
  req.session.destroy(() => res.clearCookie('hh_cust_sess').json({ ok: true }));
});
```

Mount:

```ts
app.use('/api/auth/customer', authCustomer);
```

### Admin auth routes

`src/server/routes/authAdmin.ts`

```ts
import { Router } from 'express';
import bcrypt from 'bcrypt';
import { db } from '../db';
import { admins } from '../../shared/schema';

export const authAdmin = Router();

authAdmin.post('/login', async (req, res) => {
  const { email, password } = req.body ?? {};
  const a = await db.query.admins.findFirst({ where: (t, { eq }) => eq(t.email, email) });
  if (!a || !a.active) return res.status(401).json({ error: 'Invalid credentials' });
  const ok = await bcrypt.compare(password, a.passwordHash);
  if (!ok) return res.status(401).json({ error: 'Invalid credentials' });
  req.session.adminId = a.id;
  // optional: enforce TOTP if ENV.ADMIN_2FA_ENABLED === 'true'
  return res.json({ ok: true });
});

authAdmin.post('/logout', (req, res) => {
  req.session.destroy(() => res.clearCookie('hh_admin_sess', { path: '/admin' }).json({ ok: true }));
});
```

Mount:

```ts
app.use('/admin/auth', authAdmin);
```

### Deprecate old shared login (feature-flag)

```ts
if (process.env.ENABLE_LEGACY_LOGIN === 'true') {
  app.post('/api/auth/login', /* existing handler */);
}
```

**PR 4 Output:** hard split of auth surfaces.
**Stop and verify:** Customer cookie never unlocks `/admin/*`; Admin cookie never unlocks `/api/*`.

---

## Phase 6 — CSRF per-surface + CORS verification (PR 5)

* Use two `csurf` instances with distinct cookie names:

  * Customer: mount on `/api/*`
  * Admin: mount on `/admin/*`
* Ensure `credentials: true` on frontend fetch and CORS origins exactly match Replit preview + prod.

*(Skip code here for brevity; I can drop in your exact `csurf` wiring once I see current body-parser setup.)*

---

## Phase 7 — Admin Content Transactions + Optimistic Locking (PR 6)

Wrap admin product/content updates in a transaction and check `version`.

`src/server/routes/adminProducts.ts` (update path)

```ts
import { Router } from 'express';
import { requireAdmin } from '../mw/requireAdmin';
import { db } from '../db';
import { products } from '../../shared/schema';
import { eq, and } from 'drizzle-orm';

const r = Router();

r.put('/:id', requireAdmin, async (req, res) => {
  const id = Number(req.params.id);
  const { payload, version } = req.body;

  try {
    const out = await db.transaction(async (tx) => {
      const current = await tx.query.products.findFirst({ where: (t, { eq }) => eq(t.id, id) });
      if (!current) throw new Error('Not found');
      if (current.version !== version) {
        res.status(409).json({ error: 'Version conflict', currentVersion: current.version });
        return null;
      }
      const [updated] = await tx.update(products)
        .set({ ...payload, version: version + 1 })
        .where(and(eq(products.id, id), eq(products.version, version)))
        .returning();
      return updated;
    });
    if (!out) return; // already responded 409
    res.json({ ok: true, product: out });
  } catch (e:any) {
    res.status(500).json({ error: 'Update failed', detail: e.message });
  }
});

export default r;
```

**PR 6 Output:** admin saves are atomic; race conditions return 409 with clear message.

---

## Phase 8 — Tests & E2E (PR 7)

* Unit:

  * Customer: register/login/logout; order as guest; link order post-signup; reorder
  * Admin: login/logout; create/update product; draft/publish; 409 conflict case
* Integration:

  * Cookies scoped correctly; wrong cookie returns 401
  * CSRF happy path and failure path
* E2E (Playwright):

  * Customer journey: product → checkout → account → order history → reorder
  * Admin journey: footer → `/admin/login` → update product content → refresh product page shows change

---

## Prompts to Paste into Replit AI (stepwise)

**Prompt A — PR 1 (Safety/Parity)**

```
Create branch fix/auth-separation. Add src/server/config/env.ts strict Zod loader, .env.example, src/server/security/cors.ts with allowlisted origins, and src/server/health.ts providing /health/auth and /status. Wire cookie-parser, corsMw, and healthRouter in server bootstrap. Do not alter existing auth behaviour yet. Commit as "PR1: safety and parity".
```

**Prompt B — PR 2 (Schema/Migrations)**

```
Add admins table and version column(s) via Drizzle + a SQL migration file. Create separate session tables session_customers and session_admins (connect-pg-simple). Update src/shared/schema.ts accordingly. No route changes. Commit as "PR2: schema: admins + version + session tables".
```

**Prompt C — PR 3 (Dual Sessions)**

```
Introduce customerSession (cookie hh_cust_sess, path /, sameSite Lax) and adminSession (cookie hh_admin_sess, path /admin, sameSite Strict) using connect-pg-simple against their respective tables. Set trust proxy and flip cookie.secure when x-forwarded-proto is https. Mount on /api and /admin respectively. Commit as "PR3: sessions split".
```

**Prompt D — PR 4 (Split Auth Routes + Guards)**

```
Create /api/auth/customer routes (login/register/logout) writing session.userId. Create /admin/auth routes (login/logout) writing session.adminId. Add requireCustomer and requireAdmin middleware; requireAdmin also supports ADMIN_IP_ALLOWLIST. Deprecate old /api/auth/login behind ENABLE_LEGACY_LOGIN=false. Commit as "PR4: split auth surfaces".
```

**Prompt E — PR 5 (CSRF & CORS final)**

```
Mount two csurf instances with distinct cookie names: csrf_cust on /api, csrf_admin on /admin. Ensure frontend fetch includes credentials and that allowed origins match Replit preview and production. Commit as "PR5: csurf per surface".
```

**Prompt F — PR 6 (Admin TX + Optimistic Locking)**

```
Wrap admin content/product updates in drizzle.transaction with optimistic locking on version. Return 409 on version mismatch, include currentVersion. Commit as "PR6: admin writes hardened".
```

**Prompt G — PR 7 (Tests + E2E)**

```
Add unit/integration tests for both stacks and Playwright E2E covering customer journey and admin updates. Include cookie/path assertions and CSRF tests. Commit as "PR7: tests and e2e".
```

---

# Assumptions

* You can run additional tables in the current Neon/Drizzle setup without breaking existing data.
* Frontend can be updated to call the **new endpoints** (`/api/auth/customer/*` and `/admin/auth/*`) with `credentials: 'include'`.
* Replit and production both present `x-forwarded-proto=https` behind their proxies.

If any of these are false, I’ll adapt the plan.

# Risk Zones

* **Cookie domain mismatch** (preview vs prod). Fix by setting exact origins and letting browser scope cookies correctly by path and domain.
* **Legacy shared login** referenced by frontend. We left a feature-flag path (`ENABLE_LEGACY_LOGIN`) to keep lights on during cutover.
* **Session store migration**. If your current store isn’t `connect-pg-simple`, we either switch or emulate two stores with prefixes.
* **Admin save UIs** need to send `version`. Add it to the form payload; server returns next version.
* **Ortho build** proxy headers. If `x-forwarded-proto` missing, secure cookies may remain false. Confirm upstream or force HTTPS in prod.

# Brutal Review

Your current issues match classic failure modes:

1. **One cookie for two roles** guarantees leakage.
2. **Shared login route** makes path scoping impossible.
3. **CORS + cookies** require exact origins; wildcard silently drops cookies.
4. **No transactions** on content writes → intermittent failures under concurrency.
5. **Missing NODE\_ENV** leads to wrong cookie and CSRF behaviour.

This plan directly severs the coupling, adds atomicity, and leaves a clean rollback.

**Confidence:** 0.86 (high) that the above, executed as PR-sized steps, resolves both “customer can’t stay logged in” and “admin cannot reliably save content” across Replit and prod.

If you want, I’ll stay in lockstep: tell me once **PR 1** is merged and I’ll proceed to wire CSRF and the admin TX with your existing parsers and routers rather than generic examples.
