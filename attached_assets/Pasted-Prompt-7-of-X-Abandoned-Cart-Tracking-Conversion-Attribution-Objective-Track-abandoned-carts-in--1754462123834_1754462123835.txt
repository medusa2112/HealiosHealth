Prompt 7 of X: Abandoned Cart Tracking + Conversion Attribution
Objective: Track abandoned carts in a database, store cart activity per user/session, and link Stripe checkouts back to these for conversion attribution. Enables admin analytics and retargeting features.

âœ… PHASE 1: SYSTEM SCAN (TRACKING SAFETY CHECK)
Before building, scan for:

âŒ Stateless or local-only cart logic

Any logic that only exists in localStorage or React state (no server sync)

No current /cart or carts backend route

âŒ No cart ID â†’ Stripe session link

Check if checkout sessions are created without linking to a cart_id or session token

âœ… Confirm frontend uses identifiable user_id or fallback session ID (via cookie/localStorage)

ðŸ§± PHASE 2: DB TABLE + CART SYNC ROUTES
1. ðŸ“¦ Add carts table in /db/schema.ts
ts
Copy
Edit
export const carts = pgTable("carts", {
  id: uuid("id").defaultRandom().primaryKey(),
  user_id: uuid("user_id"), // nullable for guest users
  session_token: varchar("session_token", { length: 128 }),
  items: json("items").notNull(), // { productId, quantity, price }
  created_at: timestamp("created_at").defaultNow(),
  last_updated: timestamp("last_updated").defaultNow(),
  converted_to_order: boolean("converted_to_order").default(false),
});
Supports guest tracking via session_token if not logged in.

2. ðŸ§  Add /routes/cart.ts â€” Sync Route
ts
Copy
Edit
import express from "express";
import { db } from "../db";
import { carts } from "../db/schema";
import { eq } from "drizzle-orm";
import { protectRoute } from "../lib/auth";

const router = express.Router();

// Customer or guest
router.post("/sync", async (req, res) => {
  const { session_token, items } = req.body;
  const user_id = req.user?.id ?? null;

  const existing = await db.select().from(carts).where(eq(carts.session_token, session_token));
  if (existing.length > 0) {
    await db.update(carts).set({ items, last_updated: new Date() }).where(eq(carts.session_token, session_token));
    return res.status(200).json({ updated: true });
  }

  await db.insert(carts).values({ session_token, user_id, items });
  res.status(201).json({ created: true });
});
Mount in server.ts:

ts
Copy
Edit
import cartRoutes from "./routes/cart";
app.use("/cart", cartRoutes);
3. ðŸ’» Frontend Sync Logic (Add to Cart Page)
In any cart-related component:

ts
Copy
Edit
const session_token = localStorage.getItem("session_token") || crypto.randomUUID();
localStorage.setItem("session_token", session_token);

// On every cart update
fetch("/cart/sync", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ session_token, items: currentCartItems }),
});
ðŸ”„ PHASE 3: LINK CART â†’ ORDER IN STRIPE SESSION
In your Stripe checkout session creation logic:

ts
Copy
Edit
const session = await stripe.checkout.sessions.create({
  ...,
  metadata: {
    user_id: user.id,
    cart_id: cart.id, // Fetch from DB by session_token
  }
});
In webhook /stripe.ts, on checkout.session.completed:

ts
Copy
Edit
if (session.metadata?.cart_id) {
  await db.update(carts).set({ converted_to_order: true }).where(eq(carts.id, session.metadata.cart_id));
}
ðŸ“Š PHASE 4: ADMIN CART REPORTING (Optional for Now)
Future prompt can enable:

/admin/carts â†’ view abandoned carts

Filter: last updated > 24h && converted_to_order = false

Analytics: avg cart size, abandonment % by tag/category

ðŸ§ª PHASE 5: STABILITY VALIDATION
âœ… Cart persists for both guest and logged-in users

âœ… Cart sync triggers on every cart change

âœ… New carts are created only once per session_token

âœ… Stripe metadata links cart â†’ order on conversion

âœ… Admin sees converted_to_order = true flag

âœ… Multiple orders from same cart not re-flagged

ðŸ“¦ OUTPUT FROM THIS PROMPT
carts table in DB, linked to session or user

Sync endpoint for frontend cart state

Stripe metadata ties cart to completed checkout

Webhook marks cart as "converted"

Foundation for retargeting or analytics tracking

