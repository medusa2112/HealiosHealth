Prompt 17 of X: Final QA + Security Hardening + Failover Simulation
Objective: Conduct a full-system QA audit, verify all security layers, stress-test role protection and Stripe logic, and ensure the system fails gracefully under high-risk scenarios — before going live.

✅ PHASE 1: FUNCTIONAL QA — FEATURE COMPLETENESS CHECKLIST
Check these across admin, customer, guest, and backend flows:

Area	Key Features	Status
✅ Auth	Replit Auth, role-based (admin, customer, guest)	REQUIRED
✅ Products	CRUD, variants, tags, pricing	REQUIRED
✅ Orders	Webhook, refund, dispute sync	REQUIRED
✅ Cart	Session + user carts, conversion tracking	REQUIRED
✅ Stripe	Valid checkout, metadata, refunds, discounts	REQUIRED
✅ Bundles	Multi-variant add, exclusion logic (e.g. children)	REQUIRED
✅ Reorders	Logged funnel, Stripe retry flow	REQUIRED
✅ Discounts	Admin-created, validated server-side	REQUIRED
✅ Admin Logs	Refunds, product edits, uploads	REQUIRED
✅ Abandoned Carts	Dashboard + sync logic	REQUIRED
✅ Customer Portal	Order history, reorders, address book	REQUIRED

If any are not confirmed live + wired → STOP deployment.

🔒 PHASE 2: SECURITY AUDIT — ATTACK SURFACE + ABUSE GUARDS
Risk Area	Must Be True
🧱 Admin route protection	protectRoute(["admin"]) wraps all /admin/* endpoints
🚪 Guest spoofing	Cannot access /portal or reorders without Replit Auth
🧑 Role escalation	No inline user.email.includes('admin') logic anywhere
💳 Stripe exposure	No frontend access to secret keys, no hardcoded discounts
🧵 Webhook safety	Stripe webhook is validated via signature, not blindly trusted
🖼️ File uploads	Use Cloudinary only, mime-type checked, size-capped
💣 Bundle enforcement	Children’s products cannot be added or injected into bundles
💰 Discounts	Cannot be applied unless server validates usage, expiry, count
🧪 Session replay	All Stripe sessions are idempotent + tied to real metadata
🔁 DB rollback	Manual admin actions (e.g. refunds) log to admin_logs
🕵️‍♀️ Dev console traps	No console.log, debugger, TODO, or unused routes left
🔐 ENV protection	All secrets (Stripe, Cloudinary, DB) only loaded from .env

🧪 PHASE 3: FAILOVER + CHAOS SCENARIOS
Scenario	What Should Happen
❌ Stripe webhook fails	Retry logic (or logs to monitor — prompt 18 for retries)
❌ Reorder endpoint fails	User sees graceful error, funnel logs as failed
❌ Admin uses invalid image	Upload fails safely, Cloudinary rejects
❌ Cart has deleted product	Cart entry removed, UX shows fallback
❌ Discount expired	UI message: “Code expired”
❌ Children’s variant injected into bundle manually	Backend rejects with 400
❌ User reuses used-up discount	“Usage limit reached” returned from backend
❌ Admin refunds already-refunded order	API blocks double-refund
❌ User force-navigates to /admin	Redirect to login or 403
❌ Bundle is created, then variant is deleted	Bundle edit shows warning, not breaks frontend
❌ Webhook sends unrecognised event	Handled in fallback default case without crashing

🛠️ PHASE 4: DEPLOYMENT-READY CHECKLIST
System Layer	Status
🧱 Migrations pushed	✅ npx drizzle-kit push up to date
🔑 ENV injected	✅ .env on Replit or Azure with:

STRIPE_SECRET_KEY

STRIPE_WEBHOOK_SECRET

CLOUDINARY_*

REPLIT_AUTH_*
|
| 🔐 Admin email whitelist | ✅ Set in ALLOWED_ADMIN_EMAILS |
| ⚙️ Startup test route | ✅ GET /health returns 200 |
| 🧪 Stripe test mode | ✅ Still in test mode until LIVE key swap |
| 🧪 Replit logs clean | ✅ No unhandled errors, logs silent |
| 🧪 Test suite (if any) | ✅ Manual test coverage from prompts 1–16 |

📦 SYSTEM INTEGRITY SCORE
✅ PASS if:

No unguarded roles

No critical routes exposed

No mutable data untracked

No children’s product in bundles

No pricing/discount abuse possible via frontend

Otherwise: block deployment.

🔚 READY FOR LIVE?
If ✅ everything above is clean:

Flip Stripe from test to live

Inject real Cloudinary and domain-specific keys

Deploy with logging enabled