You are a senior auth engineer. Issue: After registration, users are redirected to a Replit URL and neither admins nor clients can sign in. We want a simple, secure email verification code flow (OTP) and correct redirects.

PHASE A — CHECK FIRST (read-only)
A1. Routes & redirects
- Show code paths (file:line) for POST /api/auth/register and POST /api/auth/login.
- Identify where registration success redirects. Prove the value of any envs: SITE_URL, BASE_URL, PUBLIC_URL, REPLIT_URL, NEXT_PUBLIC_SITE_URL.
- Confirm the SPA fallback is NOT swallowing /api/* and that client routes exist for /login, /register, /verify.

A2. Email provider & secrets
- Detect email sender library (Resend/SMTP/etc.). List required secrets (e.g., RESEND_API_KEY, EMAIL_FROM). Confirm they are read from the secrets manager (not hard coded).
- If no provider configured, report “MISSING_EMAIL_PROVIDER”.

A3. Account state & RBAC
- Show DB columns related to verification: email_verified (boolean/date), verification_code/hash, verification_expires_at.
- Show how admin role is set (seed file/migration). Confirm at least one admin exists.

A4. CORS/cookies/session
- Confirm cookie domain/path/samesite for auth cookies.
- Confirm CORS allowlist includes the production domain and staging.

A5. Output Phase A report:
- Summary [≤6 bullets]
- Findings Table [ID | Area | Evidence (file:line) | Impact]
- Minimal changes needed (no code yet)

STOP if blockers exist. Otherwise continue to Phase B.

PHASE B — FIX (minimal, reversible)
Goal: Add secure email verification code flow + correct redirects; no breaking changes.

B1. Redirects
- Replace any redirect pointing at a Replit preview URL with env-driven SITE_URL.
- On register success: return JSON { ok:true } and client-side route to /verify?email=... (do NOT server-redirect off-domain).
- After successful verification: route to /account (or the protected page originally requested).

B2. Verification Code (OTP)
- Create table/columns if missing: users.email_verified (timestamp or boolean), users.verification_code_hash (varchar), users.verification_expires_at (timestamp).
- Generate a 6-digit code on registration or when “resend code” is requested:
  - code = random 6 digits; store bcrypt( code ) + expiry 15 minutes.
  - Rate limit: max 5 attempts per hour per email/IP.
- Send code via transactional email provider using secrets (e.g., Resend).
  Template subject: “Your Healios verification code”
  Body: “Your code is ${CODE}. It expires in 15 minutes. If you didn’t request this, ignore this email.”
- NEVER store plaintext codes; only store a hash.

B3. Endpoints
- POST /api/auth/register
  - Create user with email_verified = null/false.
  - Issue verification code (hashed) + expiry and send email.
  - Return JSON { ok:true }.
- POST /api/auth/verify
  - Input: { email, code }
  - Verify: compare bcrypt(code) with stored hash and expiry window.
  - On success: set email_verified=true (timestamp), clear code/hash.
  - Create session → Set-Cookie with Secure, HttpOnly, SameSite=Lax|Strict.
  - Return JSON { ok:true }.
- POST /api/auth/resend-code
  - Re-issue code with rate limit.

B4. Client pages
- /register: after success, push to /verify?email=… with copy explaining next steps.
- /verify: email input + 6-digit OTP inputs; Resend button disabled until timer (e.g., 30s).
- /login: if backend returns “email_unverified”, prompt to /verify.

B5. Admin & RBAC
- Seed at least one admin if none exists; ensure admin login requires email_verified.
- On login, deny unverified users with a specific error code { error:"email_unverified" }.

B6. Security hardening (no regressions)
- Keep CSRF for all POSTs. Include x-csrf-token on /verify and /resend-code.
- Keep CORS allowlist unchanged.
- Ensure all email/API keys are read from secrets manager (not source).

PHASE C — TESTS (run curl & logs)
C1. Happy path
- Register → expect 200 JSON; check that an email was “sent” (log output or provider dashboard).
- Verify with correct code → expect 200 JSON and Set-Cookie with Secure, HttpOnly, SameSite.
- Visit /account → allowed.

C2. Negative cases
- Wrong code → 400 with message; attempts counter increments.
- Expired code → 400 with message; allow resend.
- Unverified user tries login → 403 + { error:"email_unverified" }.

C3. Redirect sanity
- Confirm no response contains any Replit preview URL. All redirects/links use SITE_URL.

Output: 
1) Summary 
2) Findings Table with file:line diffs 
3) Evidence (curl snippets, selected logs, headers) 
4) Go/No-Go
