Prompt 10 of X: Full Role-Based Route Protection Audit (Admin / Customer / Guest)
Objective: Enforce strict, bulletproof access control across all routes (API and frontend), ensuring that no endpoint or page leaks to unauthorised users. Prevents role spoofing, frontend exposure, and backend bypass.

âœ… PHASE 1: FULL SYSTEM SCAN (AUTHORITY LAYER CHECKLIST)
Audit the system for:

1. ğŸ” Unprotected routes
âŒ Any backend API (/admin, /portal, /cart, /orders) missing a protectRoute(...) middleware

âŒ Any frontend route rendered without user role check

2. ğŸ­ Role spoofing or weak checks
âŒ Inline checks like if (user.email.includes('admin')) or if user === "admin"

âœ… Role must only be checked via:

ts
Copy
Edit
protectRoute(["admin"]) // on server
3. ğŸ§© Frontend route leaks
âŒ Public routes that render components like:

tsx
Copy
Edit
<Route path="/admin/orders" element={<AdminOrders />} />
Without a guard like <RequireRole role="admin" />

4. âœ… Fallback protection
If the frontend is bypassed (e.g. manual request via Postman), server still blocks unauthorised access

ğŸ” PHASE 2: BACKEND ROUTE WRAPPING (EXAMPLES)
1. Secure all admin routes
ts
Copy
Edit
// routes/admin/products.ts
router.use(protectRoute(["admin"]));
2. Secure all customer routes
ts
Copy
Edit
// routes/portal.ts
router.use(protectRoute(["customer"]));
3. Secure sensitive shared routes (e.g. cart, orders)
ts
Copy
Edit
// routes/cart.ts
router.use((req, res, next) => {
  if (!req.body.session_token && !req.user?.id) {
    return res.status(403).json({ error: "No session or user" });
  }
  next();
});
ğŸ§± PHASE 3: FRONTEND GUARD COMPONENT
Create /components/RequireRole.tsx:

tsx
Copy
Edit
import { useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useUser } from "../hooks/useUser"; // Assume this fetches or context-loads user

export function RequireRole({ role, children }: { role: string, children: JSX.Element }) {
  const { user, loading } = useUser();
  const navigate = useNavigate();

  useEffect(() => {
    if (!loading && (!user || user.role !== role)) {
      navigate("/auth/login");
    }
  }, [loading, user]);

  if (loading || !user) return null;
  return children;
}
ğŸš§ PHASE 4: WRAP ALL ROUTES
Admin
tsx
Copy
Edit
<Route path="/admin/products" element={
  <RequireRole role="admin"><AdminProducts /></RequireRole>
} />
Customer
tsx
Copy
Edit
<Route path="/portal" element={
  <RequireRole role="customer"><Portal /></RequireRole>
} />
ğŸ§ª PHASE 5: VALIDATION TEST MATRIX
User Role	Route	Expected Result
Admin	/admin/products	âœ… Access
Customer	/admin/products	âŒ Blocked
Guest	/admin/products	âŒ Blocked
Customer	/portal	âœ… Access
Guest	/portal	âŒ Redirect
Admin	/portal	âŒ Redirect
Anyone	/cart/sync	âœ… (requires session token)

ğŸ§  OPTIONAL FUTURE HARDENING
Feature	Why
2FA on admin	Prevent account compromise
IP allowlist for admin	Only known IPs can access panel
Role elevation log	Track if a user is granted admin
Rate limiting	Prevent brute-force auth

ğŸ“¦ OUTPUT FROM THIS PROMPT
ğŸ”’ All API routes protected with protectRoute(...) or equivalent

ğŸ” Frontend routes protected with <RequireRole />

ğŸ›¡ï¸ No path or data leaks possible via unauthorised access

âœ… Role spoofing impossible without DB compromise

âœ… SYSTEM COMPLETE (MVP HARDENED)
You now have:

Full role-auth separation

Product, order, Stripe, cart, and image flows fully scoped

Admin-only access enforced throughout

Guest checkout with email â†’ register upgrade path

Webhooks, refund triggers, and cart conversion tracking

Transactional emails linked to core events