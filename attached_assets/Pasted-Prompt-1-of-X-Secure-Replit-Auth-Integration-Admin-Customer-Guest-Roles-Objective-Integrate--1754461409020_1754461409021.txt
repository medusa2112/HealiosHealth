Prompt 1 of X: Secure Replit Auth Integration (Admin + Customer + Guest Roles)
Objective: Integrate role-based Replit Auth across your app using best-practice access control, rogue code scanning, and stability protection.

âœ… PHASE 1: SYSTEM SCAN (DO NOT SKIP)
Before applying any changes, scan the full repo for:

Rogue or unstable code:

âŒ console.log, debugger, TODO, FIXME

âŒ Inline user.role = 'admin' checks

âŒ Hardcoded admin emails

âŒ Test-only routes or leftover mocks

Drizzle schema compatibility:

Confirm existence of users table with at least:

ts
Copy
Edit
id, email, role (admin/customer/guest), created_at
Frontend routing check:

Ensure there is a working routing system (react-router-dom or equivalent)

Check for conflicting /admin, /portal, or /auth/* routes

.env check:

Validate that REPLIT_AUTH_CLIENT_ID and REPLIT_AUTH_SECRET (or equivalents) are NOT hardcoded anywhere in the app

ğŸ› ï¸ PHASE 2: APPLY THE AUTH INTEGRATION (Safely)
1. Install Replit Auth SDK
bash
Copy
Edit
npm install replit-auth-lib
2. Add lib/auth.ts:
ts
Copy
Edit
import { ReplitAuthClient } from 'replit-auth-lib';
import { Request, Response, NextFunction } from 'express';

const authClient = new ReplitAuthClient({
  clientId: process.env.REPLIT_AUTH_CLIENT_ID!,
  secret: process.env.REPLIT_AUTH_SECRET!,
  redirectUri: process.env.REPLIT_AUTH_REDIRECT_URI!,
});

export const protectRoute = (roles: ('admin' | 'customer' | 'guest')[]) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = await authClient.getUserFromRequest(req);
      if (!user || !roles.includes(user.role)) {
        return res.status(403).json({ message: 'Access denied' });
      }
      req.user = user;
      next();
    } catch (err) {
      return res.status(401).json({ message: 'Authentication failed' });
    }
  };
};

export default authClient;
3. Add /routes/auth.ts:
ts
Copy
Edit
import express from 'express';
import authClient from '../lib/auth';

const router = express.Router();

router.get('/login', (req, res) => {
  const url = authClient.getLoginUrl();
  res.redirect(url);
});

router.get('/callback', async (req, res) => {
  const user = await authClient.handleCallback(req);
  // Store user in DB if new
  // Redirect based on role
  if (user.role === 'admin') return res.redirect('/admin');
  if (user.role === 'customer') return res.redirect('/portal');
  return res.redirect('/');
});

router.get('/logout', (req, res) => {
  authClient.logout(req, res);
});

export default router;
4. Add middleware to /routes/admin.ts and /routes/portal.ts:
ts
Copy
Edit
import { protectRoute } from '../lib/auth';

router.use(protectRoute(['admin']));     // for admin.ts
router.use(protectRoute(['customer']));  // for portal.ts
5. Seed Admin Emails (temporary logic)
Create a server-safe .env value like:

env
Copy
Edit
ALLOWED_ADMIN_EMAILS=admin1@healios.com,admin2@healios.com
Then in the /callback route, assign role = admin if matched:

ts
Copy
Edit
const adminEmails = process.env.ALLOWED_ADMIN_EMAILS!.split(',');
const role = adminEmails.includes(user.email) ? 'admin' : 'customer';
ğŸ” PHASE 3: POST-INTEGRATION VALIDATION
âœ… Create test logins for:

One admin email

One customer email

One Stripe checkout session (guest)

âœ… Manually test these routes:

/admin â†’ blocked for customer/guest

/portal â†’ blocked for guest

/auth/login and /auth/logout routes function correctly

âœ… Confirm:

User data is saved in users table

Roles are correctly assigned on login

.env is not leaked or committed

ğŸ”’ PROTECTED ROUTES SUMMARY (MINIMUM VIABLE)
Route	Method	Role Allowed	Auth Required
/admin/*	GET/POST	admin only	âœ… Yes
/portal/*	GET/POST	customer only	âœ… Yes
/auth/login	GET	All	âŒ No
/auth/logout	GET	All	âŒ No

âœ… OUTPUT
After completing this prompt, the system should:

Enforce Replit Auth login across all sensitive endpoints

Route users to /admin or /portal based on role

Reject rogue access attempts

Fully segregate guest access