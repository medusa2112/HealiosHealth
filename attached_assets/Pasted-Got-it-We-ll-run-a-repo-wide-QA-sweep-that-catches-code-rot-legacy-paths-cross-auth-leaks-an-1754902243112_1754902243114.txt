Got it. We’ll run a **repo-wide QA sweep** that catches code rot, legacy paths, cross-auth leaks, and runtime misconfig. Below is a **copy-paste** package: fast manual checks, automated guards that fail the build if legacy code is detected, and end-to-end tests proving cookies, CSRF, and writes work in the browser and under the proxy.

# Answer

## 1) Rapid repo triage (run these now)

```bash
# 1) Find legacy auth and shared-cookie usage
rg -n --fixed-strings "/api/auth/login" src server client
rg -n "healios\.sid" -S
rg -n "passport|openid-client|replitAuth" -S server src
rg -n "requireAuth[^A-Za-z]" -S server
rg -n "role\s*===\s*['\"]admin['\"]" -S server

# 2) Find accidental admin-to-API or API-to-admin calls in the frontend
rg -n "/admin/auth" client | rg -v "admin-login"
rg -n "/api/auth/customer" client

# 3) Confirm only split cookies and stores are mounted
rg -n "hh_cust_sess|hh_admin_sess" -S server
rg -n "session_admins|session_customers" -S server

# 4) Hard-fail if wildcard CORS slipped in
rg -n "Access-Control-Allow-Origin.*\*" -S server

# 5) Confirm NODE_ENV used for secure cookies and trust proxy is set
rg -n "app\.set\('trust proxy',\s*1\)" server
rg -n "cookie\.secure\s*=" -n server
```

If any of the first three blocks return hits in the wrong places, we still have legacy bleed.

---

## 2) Legacy-kill guard (fails build if rot is present)

**Create:** `scripts/qa/legacy-guard.mjs`

```js
#!/usr/bin/env node
import { readFileSync, readdirSync } from "fs";
import { join } from "path";

const ROOTS = ["server", "src", "client"];
const BAD_PATTERNS = [
  { re: /\/api\/auth\/login\b/, msg: "Legacy shared login endpoint detected." },
  { re: /healios\.sid/,         msg: "Legacy shared cookie name detected." },
  { re: /\bpassport\b|\bopenid-client\b/, msg: "passport/openid-client detected; must be quarantined." },
  { re: /\breplitAuth\b/,       msg: "replitAuth found; must not touch prod auth." },
  { re: /\brequireAuth\b[^A-Za-z]/, msg: "Generic requireAuth found; must use requireCustomer/requireAdmin." },
  { re: /role\s*===\s*['"]admin['"]/, msg: "Role check used in place of admin session guard." },
  { re: /Access-Control-Allow-Origin.*\*/, msg: "Wildcard CORS found." }
];

let failures = [];

const walk = (dir) => {
  for (const entry of readdirSync(dir, { withFileTypes: true })) {
    const p = join(dir, entry.name);
    if (entry.isDirectory()) walk(p);
    else if (/\.(ts|tsx|js|cjs|mjs)$/.test(entry.name)) {
      const s = readFileSync(p, "utf8");
      for (const { re, msg } of BAD_PATTERNS) {
        if (re.test(s)) failures.push(`${msg} -> ${p}`);
      }
    }
  }
};

for (const root of ROOTS) {
  try { walk(join(process.cwd(), root)); } catch {}
}

if (failures.length) {
  console.error("❌ Legacy guard failures:");
  for (const f of failures) console.error(" -", f);
  process.exit(1);
} else {
  console.log("✅ Legacy guard clean.");
}
```

**Wire into package.json:**

```json
{
  "scripts": {
    "qa:legacy": "node scripts/qa/legacy-guard.mjs",
    "qa:types": "tsc -p tsconfig.json --noEmit",
    "qa:lint": "eslint . --ext .ts,.tsx --max-warnings=0",
    "qa:test": "vitest run || jest --ci || echo 'no test runner configured'",
    "qa:all": "npm run qa:legacy && npm run qa:types && npm run qa:lint && npm run test:e2e"
  }
}
```

**ESLint banlist (add to .eslintrc.cjs):**

```js
module.exports = {
  rules: {
    "no-restricted-imports": ["error", {
      paths: [
        { name: "passport", message: "Quarantined." },
        { name: "openid-client", message: "Quarantined." },
        { name: "../replitAuth", message: "Quarantined." }
      ],
      patterns: [
        "**/server/replitAuth*",
        "**/server/**/requireAuth*"
      ]
    }]
  }
};
```

---

## 3) Wire-level auth proof (browser reality, not mocks)

**Create:** `scripts/qa/wire-assert.mjs`

```js
#!/usr/bin/env node
import fetch from "node-fetch";
const BASE = process.env.QA_BASE || "http://localhost:5000";

const getSetCookie = (res, name) =>
  (res.headers.raw()["set-cookie"]||[]).find(c => c.startsWith(`${name}=`)) || "";

const mustInclude = (str, k) => {
  if (!str.includes(k)) throw new Error(`Missing cookie attr: ${k} in "${str}"`);
};

const main = async () => {
  // Customer CSRF
  let r = await fetch(`${BASE}/api/csrf`, { credentials: "include" });
  const custCsrf = getSetCookie(r, "csrf_cust").split(";")[0].split("=")[1];
  if (!custCsrf) throw new Error("No csrf_cust");

  // Customer login
  r = await fetch(`${BASE}/api/auth/customer/login`, {
    method: "POST",
    headers: { "Content-Type": "application/json", "X-CSRF-Token": custCsrf },
    body: JSON.stringify({ email: "user@example.com", password: "test1234" })
  });
  const custCookie = getSetCookie(r, "hh_cust_sess");
  if (!custCookie) throw new Error("No hh_cust_sess Set-Cookie");
  mustInclude(custCookie.toLowerCase(), "path=/");
  mustInclude(custCookie, "SameSite=Lax");

  // Admin CSRF
  r = await fetch(`${BASE}/admin/csrf`);
  const admCsrf = getSetCookie(r, "csrf_admin").split(";")[0].split("=")[1];
  if (!admCsrf) throw new Error("No csrf_admin");

  // Admin login
  r = await fetch(`${BASE}/admin/auth/login`, {
    method: "POST",
    headers: { "Content-Type": "application/json", "X-CSRF-Token": admCsrf },
    body: JSON.stringify({ email: "admin@healios.com", password: "adminpass" })
  });
  const adminCookie = getSetCookie(r, "hh_admin_sess");
  if (!adminCookie) throw new Error("No hh_admin_sess Set-Cookie");
  mustInclude(adminCookie.toLowerCase(), "path=/admin");
  mustInclude(adminCookie, "SameSite=Strict");

  console.log("✅ Wire cookie + CSRF assertions passed.");
};
main().catch(e => { console.error("❌", e.message); process.exit(1); });
```

**Add to scripts:**

```json
{ "scripts": { "test:e2e": "node scripts/qa/wire-assert.mjs" } }
```

---

## 4) Playwright kill-tests (optional but ideal)

Create `tests/auth.spec.ts` to run the full gauntlet in a headless browser:

* Customer login sets `hh_cust_sess` with `Path=/` and `SameSite=Lax`
* Admin login sets `hh_admin_sess` with `Path=/admin` and `SameSite=Strict`
* Cross-auth requests return 401
* Admin update returns 409 on stale version
* Guest order claim attaches to account

Say the word and I’ll drop a ready file tailored to your routes.

---

## 5) Backend transactional integrity checks

Add a quick test to assert updates are atomic and versioned:

```ts
// server/tests/admin-products.tx.test.ts (vitest or jest)
it("returns 409 on stale version", async () => {
  const a = await api.get("/admin/products/1").authAdmin();
  const stale = { ...a.body, version: a.body.version - 1 };
  await api.put("/admin/products/1").send({ payload: stale, version: stale.version }).expect(409);
});
```

---

## 6) CI/pre-deploy gate

Before any deploy (Replit or Ortho), run:

```bash
npm run qa:legacy &&
npm run qa:types &&
npm run qa:lint &&
npm run test:e2e
```

Block deploy on any non-zero exit.

---

## 7) Remove build-poisoning legacy code

* **Quarantine** `server/replitAuth.ts` and any `passport` mounts behind `ENABLE_REPLIT_OAUTH=false` and ensure they **do not** register middleware in prod.
* **Delete** any `requireAuth` that checks `role === 'admin'`.
* **Delete** references to shared cookie `healios.sid`.
* **Fence** legacy `/api/auth/login` (404 unless `ENABLE_LEGACY_LOGIN=true` explicitly set in a dev session).

---

## 8) Runtime config verification

From a prod-like environment:

```bash
curl -sS https://<host>/health/auth | jq
# Expect: nodeEnv:"production", custCookie/adminCookie states correct per surface

curl -I https://<host>/api/auth/customer/login | rg -i "cache-control"
# Expect: no-store on auth routes
```

---

# Assumptions

* You can run Node 18+ and enable `rg` (ripgrep) locally or in Replit shell.
* Seeded credentials exist to satisfy the wire assertions.

# Risk Zones

* **Dev CSRF bypass** left enabled in prod. Guard with an explicit env flag and never set it in hosted environments.
* **Wildcard CORS** reintroduced by a helper. The guard script will catch it; keep it in CI.
* **Admin UI not sending `version`** on PUT. You’ll never see 409 and will re-open race conditions.
* **Proxy misreporting protocol** so cookies miss `Secure`. Confirm `x-forwarded-proto=https` and `trust proxy`.

You can paste the scripts as-is. Run `npm run qa:all`. If anything fails, send me the exact failing output and I’ll give you pinpoint fixes without touching stable code.
